version: '3.8'

services:
  deeplx:
    image: devinglaw/deeplxtov1api:latest
    container_name: deeplxtov1api
    restart: always
    ports:
      - "38888:8000" # 将容器的 8000 端口映射到主机的 38888 端口

    # 主要配置来源：加载 ./app/.env 文件
    # 请确保您的 .env 文件位于 docker-compose.yml 同级目录下的 app 文件夹内
    env_file:
      - ./app/.env

    # environment 中只保留那些 .env 文件中没有的，或者与容器强相关的固定配置
    environment:
      # 性能优化: UVICORN_WORKERS 是 uvicorn 启动参数，在这里定义更清晰
      - UVICORN_WORKERS=2 
      # 安全和限制: 这些是固定的安全策略，不常变动
      - MAX_TEXT_LENGTH=5000
      - DEBUG=false
      # URL 管理: 初始延迟检查，属于启动策略
      - INITIAL_CHECK_DELAY=30

    volumes:
      # 将宿主机的 ./results 目录挂载到容器的 /app/results，用于持久化可用URL列表
      - ./results:/app/results
      # 同步宿主机时间
      - /etc/localtime:/etc/localtime:ro

    # 安全设置：以只读模式运行容器
    read_only: true
    
    # 关键修正：为所有需要写入的路径创建可写的 tmpfs (内存文件系统)
    tmpfs:
      - /tmp
      - /app/logs  # 为 /app/logs 目录创建可写挂载点
      
    security_opt:
      - no-new-privileges:true

    # 关键修正：覆盖启动命令，先修复所有权，再用环境变量启动应用
    command: >
      sh -c "
        # 1. 修复所有需要写入的目录和文件的所有权，交给非 root 用户 (1000:1000)
        chown -R 1000:1000 /app/logs /app/results &&
        # 2. 切换到非 root 用户，并使用从 .env 加载的环境变量来启动 uvicorn
        exec su-exec 1000:1000 uvicorn main:app --host $$HOST --port $$PORT --workers $$UVICORN_WORKERS --loop asyncio --log-level $$LOG_LEVEL
      "
    
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8000/health || exit 1"]
      interval: 30s
      timeout: 15s
      retries: 3
      start_period: 30s

    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 256M

    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"
        compress: "true"
    
    networks:
      - deeplx-network

networks:
  deeplx-network:
    driver: bridge

